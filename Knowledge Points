# Review03-ArrayList_LinkedList

一、线性表
    1、定义：线性表 是n个具有相同特性的数据元素的有限序列。 线性表是一种在实际中广 泛使用的数据结构。
    2、 常见的线性表：顺序表、链表、栈、队列、字符串...
    3、线性表在逻辑上是线性结构，也就说是连续的一条直线。但是在物理结 
          构上并不一定是连续的，线性表在物理上存储时，通常以数组和链式结
          构的形式存储。
          
二、顺序表
 1、概念和结构：顺序表是用一段物理地址连续的存储单元依次存储数据元素的线性结构，一般情况 下采用数组存储。在数组上完成数据的增删改查。
 2、一些操作：
       （1）初始化 （构造方法）
       （2） 增 / 删 / 改 / 查
             增 包括头插、尾插(O(1)平均)和指定位置插入（O（n））
             删 包括头删、尾删(O(1))和指定位置删除或者删除某个元素
             改 就是修改其中的某个元素或者信息
             查 就是遍历查找给定的数字或信息
             扩容：（O（n））
       （3）销毁（可能不存在）
       
 3、考虑 数组容量（array.length）和 已有数据个数（size）的关系
 （1）容量是够用的   size < array.length
 （2）容量不够用怎么办？
      假如：搬家   （1.5/2倍）
      int newCapacity = array.length*2;

     1)找新家  int[] newArray = new int[newCapacity];

     2)搬家
         for(int i=0; i<size; i++){
             newArray[i] = array[i];
       }

     3)发朋友圈
        this.array = newArray;
 
     4)老房子退掉
         原来的数组对象，没有引用指向，变成垃圾了
         扩容的空间越小，空间浪费越小
         扩容的空间越大，需要扩容的频率越少
         经验值  大概是1.5倍或者2倍
  
 5、IDE  （集成开发环境） Integration Development Environment
      集成开发环境是以下的总和
        Notepad++   编辑器（Text Editor）
        Javac            编译器（Compiler）
        Java              运行环境 （Runtime）
        Jdb                调试器（Debugger）


三、链表 （重点/难点）
 
 1、链表的概念
          概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元  
                    素的逻辑顺序是通过链表中的引用链接次序实现的 。
                  （逻辑上有前后关系，但在物理上不保证前后关系）    
                  
 2、链表的相关操作
 
  【插入】  
 （1）链表的头插
      1.如果要插入的数据没有结点，先给它装入一个结点中
         Node node = new Node();
         node .value = 0;
      2.让原来的第一个结点成为新结点的下一个结点
         node.next = head;
      3.更新最新的第一个结点为新结点
           head = node;
 （2）打印链表
            Node cur=head;
             while(cur!=null){
                  System.out.println(cur.val);
                 cur=cur.next;
            }
  
 （3）链表的尾插
      1.如果要插入的数据没有结点，先给它装入一个结点中
               让新结点的next=null
               Node node=new Node（val）;
      2.找到倒数第一个结点（子问题）
               Node last = head;
               while (last.next!=null)  {last = last.next;}
               last 就是最后一个结点
      3.让原来的倒数第一个结点的下一个为新结点
               last.next = node;
      4.尾插需要分情况讨论:
          （1）空链表的情况 ：就是让新的结点成为第一个结点
          （2）非空链表的情况
                   按下面处理：
                   构造方法中已经让.next=null了
                   找到.next==null的结点

  【删除】
 （1）链表的头删
           分情况讨论：
         1. 空链表，没有结点，则报错，，无法删除。
         2. 只有一个结点-------------直接删除头结点
         3. 大于一个结点
              让头结点指向链表的第二个结点。第一个结点没有引用指向，自动被系统视为垃圾处理了
 （2）链表的尾删
         1. 找到倒数第二个结点
            lastSecond . next . next==null就是倒数第二个结点
         2. 让倒数第二个结点的next = null
         3. 原来最后一个结点因为没有引用指向而被回收

 3、链表练习
 
   *****   反转一个单链表（面试题）*****
       思路： 不断从原来链表中取出结点，头插到一个新链表上
         （1）需要一个新的链表，并且是一个空链表
                Node result = null;   //result新链表的第一个结点的引用
         （2）遍历原来的链表
              Node cur = head;
              while(cur!= null){ 
              cur = cur.next;
             }
         （3）把每个遍历到的结点（cur），头插到新链表（result代表）中
                 1. 已经有结点
                 2. cur . next = result;
                 3. 更新最新的第一个结点result = cur;
                     
 4、总结：
    1. 链表相交的判断问题：
     （1）先各自求出链表的长度
     （2）让长的先走长度差步
     （3）同时走，第一次相遇时就是交点 
    2. 链表的带环问题
     （1）快慢指针（一个1步，一个2步，不能一个1步，一个n步，n>2，  可能  
               会错过）
     （2）如果相遇，带环，如果快的遇到null则不带环
     （3）求入环点
             A、转换为相交问题
             B、一个从起点出发，一个从相遇点出发，都走1步，一定相遇在入环
                  点（需要证明）
 
     3. 相交+带环问题（了解，6种情况）


四、顺序表和链表的区别和联系
       顺序表：  空间连续、支持O(1)随机访问(下标访问)
                      1.中间或前面部分的插入删除时间复杂度O(N)
                      2.增容的代价比较大。
                      3.不容易有内存碎片
                      4.对缓存更友好（了解）
                      5.单个数据而言，空间更节省
       链表：以节点为单位存储，不支持随机访问所有：
                      1.头插/尾插/头删/尾删：时间复杂度为O(1) 
                      2.如果数据比较大了，不需要预留空间，没有增容问题，插入一
                          个开辟一个空间。
      （没有特殊理由，一律用顺序表就可以了）
                          
